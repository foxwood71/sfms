version: "3.8"  # Podman 및 Docker Compose의 호환성이 가장 좋은 3.8 버전을 사용합니다.

services:
    # ====================================================================
    # 1. Database (PostgreSQL 16 + PGroonga)
    # SFMS의 모든 메인 데이터가 저장되는 핵심 관계형 데이터베이스입니다.
    # ====================================================================
    # 1. Database (PostgreSQL 16 + Custom PGroonga & pg_cron)
    # 한글 검색 최적화 및 스케줄러가 포함된 커스텀 이미지를 빌드하여 실행합니다.
    pgsql:
        # infra/pgsql 폴더에 있는 Dockerfile을 읽어 직접 이미지를 생성합니다.
        build: ./pgsql
        container_name: pgsql
        restart: always
        # entrypoint/command 는 컨테이너를 만들때 적용해서 필요없음
        environment:
            - POSTGRES_USER=${DB_USER}
            - POSTGRES_PASSWORD=${DB_PASSWORD}
            - POSTGRES_DB=${DB_NAME}
            # scram-sha-256 인증 방식을 강제하여 보안을 강화합니다.
            - POSTGRES_INITDB_ARGS=--auth-host=scram-sha-256  
            - TZ=Asia/Seoul
        # 운영 환경이므로 외부 포트 노출을 제거하여 보안을 강화
        # ports:
        #     - "5432:5432"  # 로컬 개발 환경에서 직접 접속하기 위해 개방
        volumes:
            # 실제 데이터 파일이 저장되는 경로입니다. (권한 관리를 위해 미리 생성 권장)
            - ./data/pgsql:/var/lib/postgresql/data  # Bind Mount: 로컬 폴더를 직접 마운트하여 데이터 영구 보존 및 호스트에서 직접 접근 가능
            # 로그 저장을 위한 볼륨 매핑
            - ./data/logs/pgsql:/var/log/postgresql
            # - pgsql-data:/var/lib/postgresql/data  # Named Volume: Docker 볼륨을 사용하여 데이터 영구 보존 (로컬 폴더 대신 볼륨 사용 시)
        networks:
            - sfms-net
        # 00_configure_system.sh 스크립트가 참조하는 SSL 키를 컨테이너 내부로 전달합니다.
        # /run/secrets/pgsql-key 경로로 자동 마운트됩니다.
        secrets:
            # secrets를 마운트할 때 권한 설정
            # 파일의 소유자 및 그룹에 상관없이 컨테이너 안에서 필요한 소유자 및 그룹을 변경 
            # 파일의 속성에 상관없이 컨테이너 안에서 필요한 파일 속성으로 변경
            - source: pgsql-password
              target: /run/secrets/pgsql-password
              uid: "999"    
              gid: "999"
              mode: 0400
            # - source: pgsql-key
            #   target: /run/secrets/pgsql-key
            #   uid: "999"
            #   gid: "999"
            #   mode: 0400
            # - source: pgsql-cert
            #   target: /run/secrets/pgsql-cert
            #   uid: "999"
            #   gid: "999"
            #   mode: 0444
        healthcheck:
            # -q(quiet) 옵션을 추가하면 로그가 더 깔끔해집니다.
            test: ["CMD-SHELL", "pg_isready -q -d ${DB_NAME} -U ${DB_USER}"]
            # 10초마다 상태 확인
            interval: 10s
            # 5초 안에 응답 없으면 실패로 간주
            timeout: 5s
            # 5번 연속 실패 시 'unhealthy' 상태로 변경  
            retries: 5
            # 컨테이너 시작 후 초기화 스크립트가 실행될 시간을 줍니다.
            # 이 시간 동안은 실패해도 'unhealthy'로 간주하지 않습니다.
            start_period: 30s


    # ====================================================================
    # 2. Cache & Session Store (Redis)
    # 잦은 DB 조회를 줄이고 API 응답 속도를 높이기 위한 인메모리 캐시입니다.
    # ====================================================================
    redis:
        image: redis:7-alpine
        container_name: redis
        restart: always
        # command는 컨테이너가 실행될 때 기본으로 실행할 실행 파일(또는 프로세스)을 덮어쓰는 명령어입니다.
        # 데이터를 메모리에만 두지 않고 디스크에도 주기적으로 저장(--appendonly yes)하고, 비밀번호 설정
        entrypoint: ["/bin/sh", "/usr/local/bin/entrypoint-wrapper.sh"]
        command: redis-server --appendonly yes --requirepass ${REDIS_PASSWORD:-password123!}
        environment:
            - TZ=Asia/Seoul
        # 운영 환경이므로 외부 포트 노출을 제거하여 보안을 강화
        # ports:
        #     - "6379:6379"
        volumes:
            # 설정 파일 및 래퍼 스크립트 매핑
            - ./redis/conf/redis.conf:/usr/local/etc/redis/redis.conf:ro
            - ./redis/scripts/entrypoint-wrapper.sh:/usr/local/bin/entrypoint-wrapper.sh:ro
            # 캐시 데이터 영구 보존용 로컬 폴더
            - ./data/redis:/data
            - /etc/timezone:/etc/timezone:ro
            - /etc/localtime:/etc/localtime:ro
        networks:
            - sfms-net
        secrets:
            # secrets를 마운트할 때 권한 설정
            # 파일의 소유자 및 그룹에 상관없이 컨테이너 안에서 필요한 소유자 및 그룹을 변경 
            # 파일의 속성에 상관없이 컨테이너 안에서 필요한 파일 속성으로 변경
            - source: redis-password
              target: /run/secrets/redis-password
              uid: "999"    # alpine 기반 redis 유저
              gid: "1000"   # alpine 기반 redis 그룹
              mode: 0400
            # - source: redis-key
            #   target: /run/secrets/redis-key
            #   uid: "999"    # alpine 기반 redis 유저
            #   gid: "1000"   # alpine 기반 redis 그룹
            #   mode: 0400
            # - source: redis-cert
            #   target: /run/secrets/redis-cert
            #   uid: "999"    # alpine 기반 redis 유저
            #   gid: "1000"   # alpine 기반 redis 그룹
            #   mode: 0444
        healthcheck:
            test: ["CMD", "redis-cli", "-a", "${REDIS_PASSWORD:-password123!}", "ping"]
            interval: 10s
            timeout: 5s
            retries: 5


    # ====================================================================
    # 3. S3 Compatible Storage (MinIO)
    # 도면, 보고서, 현장 이미지 등 대용량 파일을 아마존 S3와 동일한 방식으로 저장합니다.
    # ====================================================================
    minio:
        image: minio/minio:latest
        container_name: minio
        restart: always
        entrypoint: ["/bin/bash", "/usr/local/bin/entrypoint-wrapper.sh"]
        command: server /data --console-address ":9001"  # 관리자용 웹 콘솔 주소 지정
        environment:
            - MINIO_ROOT_USER=${MINIO_ROOT_USER}  # 최고 관리자 계정 아이디
            - MINIO_ROOT_PASSWORD=${MINIO_ROOT_PASSWORD}  # 최고 관리자 비밀번호
            - TZ=Asia/Seoul
        ports:
            # # S3 API 포트: 로컬 백엔드에서 파일 업로드/다운로드 테스트를 위해 개방
            # - "9000:9000"
            # # MinIO 관리자 웹 콘솔: 브라우저에서 버킷(폴더)을 관리하기 위해 개방
            # - "9001:9001"
            # [수정] 로컬 호스트(127.0.0.1)로만 바인딩하여 외부 직접 접속 차단. 
            # (웹 콘솔 접근 시 Nginx 프록시나 SSH 터널링 활용 권장)
            - "127.0.0.1:9000:9000"
            - "127.0.0.1:9001:9001"
        volumes:
            - ./minio/scripts/entrypoint-wrapper.sh:/usr/local/bin/entrypoint-wrapper.sh:ro
            - ./data/minio:/data
            - /etc/timezone:/etc/timezone:ro
            - /etc/localtime:/etc/localtime:ro
        networks:
            - sfms-net
        secrets:
           # secrets를 마운트할 때 권한 설정
            # 파일의 소유자 및 그룹에 상관없이 컨테이너 안에서 필요한 소유자 및 그룹을 변경 
            # 파일의 속성에 상관없이 컨테이너 안에서 필요한 파일 속성으로 변경
            - source: minio-password
              target: /run/secrets/minio-password
              uid: "0"    # 기본적으로 root 유저
              gid: "0"    # 기본적으로 root 그룹
              mode: 0400
            # - source: minio-key
            #   target: /run/secrets/minio-key
            #   uid: "0"    # 기본적으로 root 유저
            #   gid: "0"    # 기본적으로 root 그룹
            #   mode: 0400
            # - source: minio-cert
            #   target: /run/secrets/minio-cert
            #   uid: "0"    # 기본적으로 root 유저
            #   gid: "0"    # 기본적으로 root 그룹
            #   mode: 0444
        healthcheck:
            test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/live"]
            interval: 30s
            timeout: 20s
            retries: 3


    # ====================================================================
    # 4. Backend (FastAPI)
    # 비즈니스 로직을 처리하고 프론트엔드와 DB 사이의 통신을 담당하는 
    # API 서버입니다.
    # ====================================================================
    backend:
        # build: ../backend
        image: sfms-backend:latest  # 소스코드를 빌드한 도커 이미지 사용
        container_name: sfms-backend
        depends_on:
            db:
                condition: service_healthy
            redis:
                condition: service_healthy
            minio:
                condition: service_healthy
        restart: always
        environment:
            # 운영에서는 외부에서 Nginx를 거치므로 S3_ENDPOINT 주소를 외부 도메인에 맞게 조정
            - DATABASE_URL=postgresql+asyncpg://${DB_USER}:${DB_PASSWORD}@db:5432/${DB_NAME}
            - REDIS_URL=redis://:${REDIS_PASSWORD:-password123!}@redis:6379/0
            - S3_ENDPOINT=http://minio:9000
            - TZ=Asia/Seoul
        volumes:
            # 운영 환경에서는 보안과 안정성을 위해 이미지 빌드 시 소스 코드를 포함.
            # - ../backend:/app
            - ./data/logs/backend:/app/logs
            - /etc/timezone:/etc/timezone:ro
            - /etc/localtime:/etc/localtime:ro
        networks:
            - sfms-net
        secrets:
            - source: sfms-backend-password
              target: /run/secrets/sfms-backend-password
              uid: "0"    # 기본적으로 root 유저
              gid: "0"    # 기본적으로 root 그룹
              mode: 0400
            # - source: sfms-backend-key
            #   target: /run/secrets/sfms-backend-key
            #   uid: "0"    # 기본적으로 root 유저
            #   gid: "0"    # 기본적으로 root 그룹
            #   mode: 0400
            # - source: sfms-backend-cert
            #   target: /run/secrets/sfms-backend-cert
            #   uid: "0"    # 기본적으로 root 유저
            #   gid: "0"    # 기본적으로 root 그룹
            #   mode: 0444


    # ====================================================================
    # 5. Frontend (React + Vite)
    # 사용자에게 제공되는 웹 UI 화면을 구성하는 프론트엔드 서버입니다.
    # ====================================================================
    frontend:
        image: sfms-frontend:latest  # 소스코드를 빌드한 도커 이미지 사용
        # build: ../frontend
        container_name: sfms-frontend
        restart: always
        environment:
            - TZ=Asia/Seoul
        #  소스 코드 및 node_modules 마운트 완전 제거.
        # 운영용 이미지 빌드 시 `npm run build` 결과물을 서빙하도록 처리
        # volumes:
        #     - ../frontend:/app
        #     - /app/node_modules
        networks:
            - sfms-net
        secrets:
            - source: sfms-frontend-password
              target: /run/secrets/sfms-frontend-password
              uid: "0"    # 기본적으로 root 유저
              gid: "0"    # 기본적으로 root 그룹
              mode: 0400
            # - source: sfms-frontend-key
            #   target: /run/secrets/sfms-frontend-key
            #   uid: "0"    # 기본적으로 root 유저
            #   gid: "0"    # 기본적으로 root 그룹
            #   mode: 0400
            # - source: sfms-frontend-cert
            #   target: /run/secrets/sfms-frontend-cert
            #   uid: "0"    # 기본적으로 root 유저
            #   gid: "0"    # 기본적으로 root 그룹
            #   mode: 0444


    # ====================================================================
    # 6. Gateway (Nginx)
    # 외부의 트래픽을 받아 프론트엔드나 백엔드로 알맞게 분배해주는 리버스
    # 프록시 서버입니다.
    # ====================================================================
    nginx:
        image: nginx:alpine
        container_name: sfms-nginx
        depends_on:
            - sfms-backend
            - sfms-frontend
        restart: always
        entrypoint: ["/bin/sh", "/usr/local/bin/entrypoint-wrapper.sh"]
        environment:
            - TZ=Asia/Seoul
        ports:
            # 외부 클라이언트가 유일하게 접속하는 포트
            - "80:80"  # HTTP 기본 포트
            - "443:443"  # HTTPS 보안 포트
        volumes:
            - ./nginx/scripts/entrypoint-wrapper.sh:/usr/local/bin/entrypoint-wrapper.sh:ro
            # 로그 저장을 위한 볼륨 매핑
            - ./data/logs/nginx:/var/log/nginx
            - ./nginx/conf.d/default.conf:/etc/nginx/conf.d/default.conf:ro
            - ./nginx/certs:/etc/nginx/certs:ro
            # (선택 사항) 만약 Nginx가 프론트엔드 파일을 직접 서빙한다면?
            # - ./frontend/dist:/usr/share/nginx/html:ro
            - /etc/timezone:/etc/timezone:ro
            - /etc/localtime:/etc/localtime:ro            
        networks:
            - sfms-net
        secrets:
            - source: nginx-password
              target: /run/secrets/nginx-password
              uid: "0"    # 기본적으로 root 유저
              gid: "0"    # 기본적으로 root 그룹
              mode: 0400
            - source: nginx-key
              target: /run/secrets/nginx-key
              uid: "0"    # 기본적으로 root 유저
              gid: "0"    # 기본적으로 root 그룹
              mode: 0400
            - source: nginx-cert
              target: /run/secrets/nginx-cert
              uid: "0"    # 기본적으로 root 유저
              gid: "0"    # 기본적으로 root 그룹
              mode: 0444


    # ====================================================================
    # 7. Database Admin (PgAdmin)
    # 브라우저에서 접속하여 엑셀처럼 DB 테이블을 조회하고 SQL을 날릴 수 있는 관리자 도구입니다.
    # ====================================================================
    pgadm:
        image: dpage/pgadmin4
        container_name: pgadm
        restart: always
        entrypoint: ["/bin/bash", "/usr/local/bin/entrypoint-wrapper.sh"]
        environment:
            - PGADMIN_DEFAULT_EMAIL=${PGADMIN_EMAIL}  # 로그인에 사용할 이메일 아이디
            - PGADMIN_DEFAULT_PASSWORD=${PGADMIN_PASSWORD}  # 로그인 비밀번호
            - TZ=Asia/Seoul
        ports:
        # [수정] 127.0.0.1 로컬 바인딩으로 외부 접근 원천 차단
            - "127.0.0.1:5050:80"  # 로컬 브라우저에서 localhost:5050 으로 접속하기 위해 매핑
        volumes:
            - ./pgadm/scripts/entrypoint-wrapper.sh:/usr/local/bin/entrypoint-wrapper.sh:ro
            - ./data/pgadm:/var/lib/pgadmin  # 계정 설정 및 쿼리 기록 저장용 로컬 폴더
            - /etc/timezone:/etc/timezone:ro
            - /etc/localtime:/etc/localtime:ro

        networks:
            - sfms-net
        secrets:
            - source: pgadm-password
              target: /run/secrets/pgadm-password
              uid: "5050"    # 기본적으로 root 유저
              gid: "5050"    # 기본적으로 root 그룹
              mode: 0400
            - source: pgadm-key
              target: /run/secrets/pgadm-key
              uid: "5050"    # 기본적으로 root 유저
              gid: "5050"    # 기본적으로 root 그룹
              mode: 0400
            - source: pgadm-cert
              target: /run/secrets/pgadm-cert
              uid: "5050"    # 기본적으로 root 유저
              gid: "5050"    # 기본적으로 root 그룹
              mode: 0444


    # ====================================================================
    # 8. Offline Version Control (Gitea)
    # 사내망(오프라인)에서도 소스 코드를 안전하게 관리하기 위한 경량화 로컬 Git 서버입니다.
    # ====================================================================
    gitea:
        image: gitea/gitea:latest
        container_name: gitea
        depends_on:
            db:
                condition: service_healthy  # DB가 먼저 완전히 켜진 후에 Gitea를 실행합니다.
        restart: always
        entrypoint: ["/bin/bash", "/usr/local/bin/entrypoint-wrapper.sh"]
        environment:
            - USER_UID=1000  # Podman Rootless 환경에서 권한 꼬임을 방지하기 위한 호스트 유저 매핑
            - USER_GID=1000
            - DB_TYPE=postgres  # Gitea의 데이터도 우리가 띄운 메인 PostgreSQL DB에 저장합니다.
            - HOST=db:5432
            - NAME=${DB_NAME}
            - USER=${DB_USER}
            - PASSWD=${GITEA_DB_PASSWORD}
            - TZ=Asia/Seoul
        ports:
            # SSH 포트(222)는 팀원 접근을 위해 개방하되 웹 UI는 내부망/로컬 호스트로 제한 추천
            - "127.0.0.1:3000:3000"  # 로컬 브라우저에서 Gitea 웹 화면 접속 포트
            - "222:22"  # SSH를 통한 Git Clone 등을 위한 포트
        volumes:
            - ./gitea/scripts/entrypoint-wrapper.sh:/usr/local/bin/entrypoint-wrapper.sh:ro
            - ./data/gitea/conf:/data/gitea/conf  # 설정(Brain) 파일 저장 위치
            - ./data/gitea/data:/data  # 소스 코드 저장소(레포지토리) 실제 저장 위치
            - /etc/timezone:/etc/timezone:ro
            - /etc/localtime:/etc/localtime:ro
        networks:
            - sfms-net
        secrets:
            - source: gitea-password
              target: /run/secrets/gitea-password
              uid: "1000"    # 기본적으로 root 유저
              gid: "1000"    # 기본적으로 root 그룹
              mode: 0400
            - source: gitea-key
              target: /run/secrets/gitea-key
              uid: "1000"    # 기본적으로 root 유저
              gid: "1000"    # 기본적으로 root 그룹
              mode: 0400
            - source: gitea-cert
              target: /run/secrets/gitea-cert
              uid: "1000"    # 기본적으로 root 유저
              gid: "1000"    # 기본적으로 root 그룹
              mode: 0444


    # ====================================================================
    # 9. Container Management (Portainer)
    # 브라우저에서 실행 중인 컨테이너 상태를 모니터링하고 클릭으로 끄고 켤 수 있는 도구입니다.
    # ====================================================================
    portainer:
        image: portainer/portainer-ce:latest
        container_name: portainer
        restart: always
        environment:
            - TZ=Asia/Seoul
        ports:
            # [수정] 포테이너 역시 강력한 권한을 가지므로 외부 공개 금지
            - "127.0.0.1:9443:9443"
            - "127.0.0.1:9002:9000"  # MinIO의 9000 포트와 겹치지 않게 호스트에서는 9002로 접속합니다.
            - "127.0.0.1:8000:8000"
        volumes:
            # [중요] Podman 소켓 연결 (Rootless 환경에서는 경로 확인 필요)
            - /run/user/1000/podman/podman.sock:/var/run/docker.sock:ro
            # 래퍼 스크립트 매핑
            - ./portainer/scripts/entrypoint-wrapper.sh:/usr/local/bin/entrypoint-wrapper.sh:ro
            - ./data/portainer:/data  # 포테이너 환경 설정 데이터 저장
            - /etc/timezone:/etc/timezone:ro
            - /etc/localtime:/etc/localtime:ro
        networks:
            - sfms-net
        secrets:
            - source: portainer-password
              target: /run/secrets/portainer-password
              uid: "0"    # 기본적으로 root 유저
              gid: "0"    # 기본적으로 root 그룹
              mode: 0400
            - source: portainer-key
              target: /run/secrets/portainer-key
              uid: "0"    # 기본적으로 root 유저
              gid: "0"    # 기본적으로 root 그룹
              mode: 0400
            - source: portainer-cert
              target: /run/secrets/portainer-cert
              uid: "0"    # 기본적으로 root 유저
              gid: "0"    # 기본적으로 root 그룹
              mode: 0444


# ====================================================================
# [컨테이너들이 서로를 컨테이너 이름(예: 'db', 'redis')으로
# 찾을 수 있게 해주는 가상 네트워크
# ==================================================================== 
networks:
    sfms-net:
        driver: bridge
        # external: false   


# ====================================================================
# Secrets 정의
# ====================================================================
secrets:
    pgsql-password:
        file: ${PWD}/pgsql/secrets/password.txt
    # pgsql-key:
    #     file: ${PWD}/pgsql/certs/pgsql.key
    # pgsql-cert:
    #     file: ${PWD}/pgsql/certs/pgsql.crt
    redis-password:
        file: ${PWD}/redis/secrets/password.txt
    # redis-key:
    #     file: ${PWD}/redis/certs/redis.key
    # redis-cert:
    #     file: ${PWD}/redis/certs/redis.crt
    minio-password:
        file: ${PWD}/minio/secrets/password.txt
    # minio-key:
    #     file: ${PWD}/minio/certs/minio.key
    # minio-cert:
    #     file: ${PWD}/minio/certs/minio.crt
    sfms-backend-password:
        file: ${PWD}/backend/secrets/password.txt
    # sfms-backend-key:
    #     file: ${PWD}/backend/certs/backend.key
    # sfms-backend-cert:
    #     file: ${PWD}/backend/certs/backend.crt
    # sfms-frontend-password:
    #     file: ${PWD}/frontend/secrets/password.txt
    # sfms-frontend-key:
    #     file: ${PWD}/frontend/certs/frontend.key
    # sfms-frontend-cert:
    #    file: ${PWD}/frontend/certs/frontend.crt
    nginx-password:
        file: ${PWD}/nginx/secrets/password.txt
    nginx-key:
        file: ${PWD}/nginx/certs/nginx.key
    nginx-cert:
        file: ${PWD}/nginx/certs/nginx.crt
    pgadm-password:
        file: ${PWD}/pgadm/secrets/password.txt
    pgadm-key:
        file: ${PWD}/pgadm/certs/pgadm.key
    pgadm-cert:
        file: ${PWD}/pgadm/certs/pgadm.crt
    gitea-password:
        file: ${PWD}/gitea/secrets/password.txt
    gitea-key:
        file: ${PWD}/gitea/certs/gitea.key
    gitea-cert:
        file: ${PWD}/gitea/certs/gitea.crt
    portainer-password:
        file: ${PWD}/portainer/secrets/password.txt
    portainer-key:
        file: ${PWD}/portainer/certs/portainer.key
    portainer-cert:
        file: ${PWD}/portainer/certs/portainer.crt


# ====================================================================
# volumes 정의
# 운영 환경에서는 보안과 안정성을 위해 Volumes의 사용을 검토
# ====================================================================
# volumes:
    # pgsql-data:
    #     driver: local
    #     driver_opts:
    #     type: none
    #     o: bind
    #     device: ${PWD}/data/pgsql
    # redis-data:
    #     driver: local
    #     driver_opts:
    #     type: none
    #     o: bind
    #     device: ${PWD}/data/redis
    # minio-data:
    #     driver: local
    #     driver_opts:
    #     type: non
    #     o: bind
    #     device: ${PWD}/data/minio
    # # backend-data: # 불필요, log는 볼륨으로 따로 빼서 관리
    # # frontend-data: # 전부불필요
    # # nginx-data: # 불필요, log는 볼륨으로 따로 빼서 관리
    #  pgadm-data:
    #      driver: local
    #      driver_opts:
    #      type: none
    #      o: bind
    #      device: ${PWD}/data/pgadm
    #  gitea-data:
    #      driver: local
    #      driver_opts:
    #      type: none
    #      o: bind
    #      device: ${PWD}/data/gitea/data
    #  gitea-conf:
    #      driver: local
    #      driver_opts:
    #      type: none
    #      o: bind
    #      device: ${PWD}/data/gitea/conf
